# AuthN and AuthZ technologies

This is a review for the state-of-the-art major authN and authZ technologies in Grid Computing. 



## Public Key Infrastructure (PKI)

A public key infrastructure consists of:

 - A certificate authority (CA) that issues and verifies digital certificate. A certificate includes the public key or information about the public key.
 - A registration authority (RA) that acts as the verifier for the certificate authority before a digital is issued.
 - One or more directories where the certificates (with their public keys) are held.


![Schema](Public-Key-Infrastructure.png)


## Kerberos 

Kerberos is a secure, single-sign-on, trusted, third-party mutual authentication service. 
There is a component called _Key Distribution Center_ (KDC) that consists of three logical components: a database of all principals and their associated encryption keys, the Authentication Server, and the Ticket Granting Server. 

###Concepts
_Principal_: Every entity contained within a Kerberos installation, including individual users, computers, and services running on servers, has a principal associated with it. Each principal is associated with a long-term key.

_Realm_: Each Kerberos installation defines an administrative realm of control that is distinct from every other Kerberos installation.

_Key_: Are shared in between two parties, a user or service and the KDC.

_Authentication Server_: The Authentication Server (AS) issues an encrypted Ticket Granting Ticket (also known as a TGT) to clients who wish to "log in" to the Kerberos realm. The client does not have to prove its identity to the KDC; instead, the TGT that is sent back to the client is encrypted in the user's password. Since only the user and the KDC know the user's password, when the login process attempts to decrypt the ticket using the password supplied by the user, only the correct password will correctly decrypt the ticket. If an incorrect password is used, the ticket will decrypt into garbage, and the user is prompted to try again. 

 _Key Distribution Center_ : described before.

_Ticket Granting Server_: issues individual service tickets to clients as they request them.

_Ticket_: it is like a license (issued by the KDC) that confirms your identity. Just like a license in the real world, each ticket issued by Kerberos includes data about you.

### Protocols

#### Needham-Schroeder Protocol

This protocol is the base of Kerberos AuthN method.

The concept behind the Needham-Schroeder protocol is not to authenticate the user directly by sending a password or password equivalent (such as a hash of the password) to the authentication server. Instead, the Needham-Schroeder protocol provides a mechanism to securely distribute a short-lived encryption key to two parties (a client and a server) so their communication can be secured with the encryption key. The verification of each endpoint's identity happens to be a side effect of this key exchange process. 

The protocol begins with the client contacting the authentication server. The client sends the authentication server a message containing the its own identity and the identity of the application server that it wishes to contact. In addition, the client includes a nonce, or a random value, with its request.

The authentication server receives this information and locates the secret encryption keys it has stored for both the client and application server. It also creates a third key, the session key, which can be used to enable secure communication between the client and application server. This new key is a random key generated by the authentication server, is completely unrelated to the long-term keys of both the client and server, and is never reused. 

Next comes the tricky part. In the Needham-Schroeder protocol, the authentication server never communicates directly with the application server, only the client. Therefore, the authentication server sends a reply back to the client that includes the session key and the verified identities of both parties. But how can this message be kept secure from an observer who is watching network traffic to snag these session keys as they pass through the wire? And furthermore, when the client transmits the session key and its identity to the application server, how does the application server know that the client is not lying, and that the message is authentic? 
The answer involves several layers of encryption. First, a message is constructed that is intended to be viewed only by the application server. This message includes the name of the requesting client and the session key. To keep this message secure from eavesdropping and tampering by a malicious client, it is encrypted with the long-term key of the application server. Since only the application server and the authentication server know this key, an attacker cannot decrypt this message to alter the contents or steal the session key. In Kerberos terminology, this encrypted message is also known as a ticket. 

The message is wrapped inside of another message, this one intended for the client. The client message also includes the name of the application server, a copy of the session key, and a copy of the nonce originally sent in the first message. The whole message is then encrypted with the client's long-term key. Once all the information has been assembled and encrypted, the authentication server sends it to the client.

#### ASN.1

ASN.1 is an acronym for Abstract Syntax Notation One. It defines a methodology for describing protocol definitions in an abstract notation, and then provides several methods to convert those abstract definitions into a stream of bytes for transmission over a communications network.

### Heimdal

Heimdal is an open source implementation of Kerberos 5. 

Here is a very useful video for a [crash introduction to Heimdal](http://www.youtube.com/watch?v=b2BdTXb5nds)

[Kerberos walktrough](http://www.kerberos-walkthrough.de)

## LDAP
LDAP stands for Lightweight Directory Access Protocol â€” it is not itself either hardware or software, but a protocol to define how a client and server interact with each other. An LDAP directory is used to describe a directory whose server corresponds to this protocol.

### OpenLDAP
[openLdap website](http://www.openldap.org/)

## DEMO 1
Here it is shown the first [demo sample](demo1.html) for deploying ssh kerberized.

## DEMO 2
Here it is shown the [second demo sample](demo2.html) for securing an apache web application.

## Integrating OpenLDAP with Kerberos Heimdal

<!--[guide 1](http://www.linux-mag.com/id/4738/?site=linuxonblades&sid=main)
[guide 2](http://www.linux-mag.com/id/4765/)
-->

### Set the virtual machines  
We copy the image from /lustre/rz/vpenso/images/debian64-6.0.4-chef-client-0.10.8.kvm.tgz into lxgrid5.gsi.de (this is just an example system).  

Inside lxgrid5.gsi.de I have lxcm01.devops.gsi.de as Chef-server. All machines will have Chef-client and will connect to it. Actually, I have chosen to distribute an image with already a chef client on it to save time.  

With each virtual machine, we will proceed this way (we are considering we already have defined the network bridge and we have assigned corresponding ip addresses).

    --bash
    amontiel@lxgrid5:/srv/vms/lxb001.devops.gsi.de$ cp -r ../debian64-6.0.4-chef-client-0.10.8/keys/ .  
    amontiel@lxgrid5:/srv/vms/lxb001.devops.gsi.de$ cp ../debian64-6.0.4-chef-client-0.10.8/disk.img  
    amontiel@lxgrid5:/srv/vms/lxb001.devops.gsi.de$ virsh create ./libvirt_instance.xml  
    amontiel@lxgrid5:/srv/vms/lxb001.devops.gsi.de$ vmname lxb001.devops.gsi.de  10.1.1.4  


### Install Heimdal

This is a summary of a more extensive documentation in [heimdal website](http://www.h5l.org).

We download the cookbook from [gitorius](http://gitorious.gsi.de/).  I have it already on my chef-server at lxcm01.devops.gsi.de.  
We can check our cookbooks just by:  

    --bash
    devops@lxcm01:~$ knife cookbook list
    heimdal   0.0.1
    lazydns   0.2.0
    nis       0.1.2
    ntp       0.1.0
    resolv    1.0.0


To connect any machine (lxb001.devops.gsi.de in the example) to chef-server we have to configure the client to connect to the server. We indicate this inside /etc/chef/client.rb:  

    --bash
    devops@lxb001:/etc/chef$ cat client.rb 
    log_level        :info
    log_location     STDOUT
    chef_server_url  'http://lxcm01.devops.gsi.de:4000'
    validation_client_name "chef-validator"
    validation_key "/etc/chef/validation.pem"
    client_key "/etc/chef/client.pem"
    file_cache_path "/srv/chef/cache"
    pid_file "/var/run/chef/chef-client.pid"


Now we copy the validation.pem certificate into the right place. Previosly I have copied this certificate outside the chef-server, in the directory that contains the vm. 

    --bash
     amontiel@lxgrid5:/srv/vms/lxb001.devops.gsi.de$ cp ../lxcm01.devops.gsi.de/validation.pem .
     amontiel@lxgrid5:/srv/vms/lxb001.devops.gsi.de$ vmput validation.pem /tmp/
     Warning: Permanently added '10.1.1.4' (RSA) to the list of known hosts.
     validation.pem                                                                                            100%      1675     1.6KB/s   00:00    
     amontiel@lxgrid5:/srv/vms/lxb001.devops.gsi.de$ vmssh 'sudo mv /tmp/validation.pem /etc/chef/'


Now if we restart the chef-client inside lxb001.devops.gsi.de, it should connect directly to the chef-server. 


    --bash
    devops@lxb001:/etc/chef$ sudo /etc/init.d/chef-client restart
    Restarting chef-client: chef-client.
    devops@lxb001:/etc/chef$ tail -f /var/log/chef/client.log 
    [Thu, 10 May 2012 16:21:36 +0200] INFO: *** Chef 0.10.8 ***
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Client key /etc/chef/client.pem is not present - registering
    [Thu, 10 May 2012 16:21:37 +0200] INFO: HTTP Request Returned 404 Not Found: Cannot load node lxb001.devops.gsi.de
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Run List is []
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Run List expands to []
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Starting Chef Run for lxb001.devops.gsi.de
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Running start handlers
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Start handlers complete.
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Loading cookbooks []
    [Thu, 10 May 2012 16:21:37 +0200] WARN: Node lxb001.devops.gsi.de has an empty run list.
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Chef Run complete in 0.159305 seconds
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Running report handlers
    [Thu, 10 May 2012 16:21:37 +0200] INFO: Report handlers complete


We want to run Heimdal __server__, so we edit the attributes of the node we just created according to our needs. It should look something like this: 


    --bash
    {
    "normal": {
    "tags": [
    ],
    "krb5": {
      "adm_server": "lxb001.devops.gsi.de",
      "realm_name": "DEVOPS.GSI.DE",
      "kdc": "lxb001.devops.gsi.de"
    }
    },
    "name": "lxb001.devops.gsi.de",
    "chef_environment": "_default",
    "run_list": [
    "recipe[heimdal::server]",
     "recipe[ntp]"
     ]
    }


With this recipe we have installed the necessary packages, created the initial database and defined the initial ACLs.  


We check everything is there the way we want: 

 * The configuration file for our realm: /etc/krb5.conf

    --bash
    root@lxb001:/home/devops# cat /etc/krb5.conf
    [libdefaults]  
	default_realm		= DEVOPS.GSI.DE
	ticket_lifetime		= 28800
	dns_lookup_realm 	= false
	dns_lookup_kdc 		= false
	fcc-mit-ticketflags 	= true
        forwardable = TRUE
    [realms]

	DEVOPS.GSI.DE = {
	 	kdc 		     = lxb001.devops.gsi.de
		admin_server 	     = lxb001.devops.gsi.de
		default_domain 	     = devops.gsi.de
	}

    [domain_realm]
	.devops.gsi.de = DEVOPS.GSI.DE
	devops.gsi.de = DEVOPS.GSI.DE

    [logging]
    default = FILE:/var/log/heimdal/default.log

__To make forwardable tickets we set the option [libdefaults] forwardable = TRUE__ also in the clients.

 * The file where the master key of the whole database is created: 

    --bash
    root@lxb001:/home/devops# ls -la  /var/lib/heimdal-kdc/m-key
    -rw------- 1 root root 74 May 10 16:54 /var/lib/heimdal-kdc/m-key

 * The configuration file for the Key Distribution Center (KDC) server

    --bash
    root@lxb001:/home/devops# cat /etc/heimdal-kdc/kdc.conf 
    [kdc]
	database = {
	dbname = /var/lib/heimdal-kdc/devops.gsi.de
	realm =  DEVOPS.GSI.DE
	acl_file = /etc/heimdal-kdc/kadm5.acl
	key_stash_file = /etc/heimdal-kdc/stash
 	max_life = 24h 0m 0s
	max_renewable_life = 7d 0h 0m 0s
	master_key_type = des3-cbc-sha1
	supported_enctypes = des3-hmac-sha1:normal des-cbc-crc:normal des3-cbc-sha1:normal aes256-cts-hmac-sha1-96 
       default_principal_flags = +preauth

    }

    [logging]
	kdc		= FILE:/var/log/heimdal/kdc.log
	kadmind		= FILE:/var/log/heimdal/kadmin.log
	kpasswdd	= FILE:/var/log/heimdal/kpasswdd.log
	default		= FILE:/var/log/heimdal/heimdal.log

    # detach = boolean

    # Gives an upper limit on the size of the requests that the kdc is
    # willing to handle.
    # max-request =  integer

    # Turn off the requirement for pre-autentication in the initial AS-
    # REQ for all principals.  The use of pre-authentication makes it
    # more difficult to do offline password attacks.  You might want to
    # turn it off if you have clients that don't support pre-authenti-
    # cation.  Since the version 4 protocol doesn't support any pre-
    # authentication, serving version 4 clients is just about the same
    # as not requiring pre-athentication.  The default is to require
    # pre-authentication.  Adding the require-preauth per principal is
    # a more flexible way of handling this.
    # require-preauth = boolean
    
    # Specifies the set of ports the KDC should listen on.  It is given
    # as a white-space separated list of services or port numbers.
    # ports = 88,750
    
    # The list of addresses to listen for requests on.  By default, the
    # kdc will listen on all the locally configured addresses.  If only
    # a subset is desired, or the automatic detection fails, this
    # option might be used.
    # addresses = list of ip addresses
    
    # respond to Kerberos 4 requests
    # enable-kerberos4 = false
    
    # respond to Kerberos 4 requests from foreign realms.  This is a
    # known security hole and should not be enabled unless you under-
    # stand the consequences and are willing to live with them.
    # enable-kerberos4-cross-realm = false
    
    # respond to 524 requests
    # enable-524 = value of enable-kerberos4
        
    # Makes the kdc listen on port 80 and handle requests encapsulated
    # in HTTP.
    # enable-http = boolean
    
    # What realm this server should act as when dealing with version 4
    # requests.  The database can contain any number of realms, but
    # since the version 4 protocol doesn't contain a realm for the
    # server, it must be explicitly specified.  The default is whatever
    # is returned by krb_get_lrealm().  This option is only availabe if
    # the KDC has been compiled with version 4 support.
    # v4-realm = string
    
    # Enable kaserver emulation (in case it's compiled in).
    # enable-kaserver = false
   
 
 * And also, we check the processes running: 

    --bash
    root@lxb001:/home/devops# ps -fea | grep heim
    root     13456     1  0 10:34 ?        00:00:00 /usr/lib/heimdal-servers/kdc --    config-file=/etc/heimdal-kdc/kdc.conf
    root     13457     1  0 10:34 ?        00:00:00 /usr/lib/heimdal-servers/    kpasswdd
    root@lxb001:/home/devops# tail -4 /etc/inetd.conf 
    #:OTHER: Other services
            
    kerberos-adm	stream	tcp	nowait	root	/usr/sbin/tcpd /usr/lib/heimdal-servers/kadmind
    #krb_prop	stream	tcp	nowait	root	/usr/sbin/tcpd /usr/sbin/hpropd


 * We can check locally the database: 

    --bash
    root@lxb001:/home/devops# kadmin -l
    kadmin> list *
    default
    kadmin/admin
    kadmin/hprop
    kadmin/changepw
    changepw/kerberos
    WELLKNOWN/ANONYMOUS
    krbtgt/DEVOPS.GSI.DE

 * We change the password for the kadmin/admin user. All modifications of principals are done with with kadmin. A principal has several attributes and lifetimes associated with it. We create a user principal for starting: 

    --bash
    root@lxb001:/home/devops# kadmin -l
    kadmin> cpw kadmin/admin
    kadmin/admin@DEVOPS.GSI.DE's Password: 
    Verifying - kadmin/admin@DEVOPS.GSI.DE's Password: 
    kadmin> add almudena
    Max ticket life [1 day]:
    Max renewable life [1 week]:
    Principal expiration time [never]:
    Password expiration time [never]:
    Attributes []:
    almudena@DEVOPS.GSI.DE's Password: 
    Verifying - almudena@DEVOPS.GSI.DE's Password: 
    kadmin> list *
    default
    almudena
    kadmin/admin
    kadmin/hprop
    kadmin/changepw
    changepw/kerberos
    WELLKNOWN/ANONYMOUS
    krbtgt/DEVOPS.GSI.DE
    kadmin> list -l almudena
            Principal: almudena@DEVOPS.GSI.DE
    Principal expires: never
     Password expires: never
     Last password change: 2012-05-11 09:52:26 UTC
      Max ticket life: 1 day
       Max renewable life: 1 week
                 Kvno: 1
                Mkvno: unknown
    Last successful login: never
    Last failed login: never
       Failed login count: 0
        Last modified: 2012-05-11 09:52:26 UTC
             Modifier: kadmin/admin@DEVOPS.GSI.DE
           Attributes: 
             Keytypes: aes256-cts-hmac-sha1-96(pw-salt), des3-cbc-sha1(pw-salt), arcfour-hmac-md5(pw-salt)
          PK-INIT ACL: 
              Aliases: 

 * We will allow the user kadmin/admin to access remotely. We set this in the acl: 

    --bash
    root@lxb001:/home/devops# cat /etc/heimdal-kdc/kadmind.acl 
    #principal       [priv1,priv2,...]       [glob-pattern]
    kadmin/admin	all
    root@lxb001:/home/devops# /etc/init.d/heimdal-kdc restart
    Stopping Heimdal password server: kpasswdd.
    Stopping Heimdal KDC: heimdal-kdc.
    Starting Heimdal KDC: heimdal-kdc.
    Starting Heimdal password server: kpasswdd.  


For the __clients__, we change the recipe to be executed to heimdal::client, like this:

    --bash
    {
     "normal": {
     "tags": [
    ],
    "krb5": {
       "adm_server": "lxb001.devops.gsi.de",
       "realm_name": "DEVOPS.GSI.DE",
       "kdc": "lxb001.devops.gsi.de"
     }
    },
     "name": "lxb002.devops.gsi.de",
     "chef_environment": "_default",
     "run_list": [
     "recipe[heimdal::client]",
     "recipe[ntp]"
     ]
    }

We check that everything is there in the way we want: 

 * The configuration file is the same as in the server: /etc/krb5.conf
 * The processes running.

Because we added before in the ACL the access to the admin user, then we should be able to access through it. 
We need to create a principal for the ssh server.

    --bash
    devops@lxb002:/etc$ /usr/sbin/kadmin -p kadmin/admin
    kadmin> list *
    kadmin/admin@DEVOPS.GSI.DE's Password: 
    default
    almudena
    kadmin/admin
    kadmin/hprop
    kadmin/changepw
    changepw/kerberos
    WELLKNOWN/ANONYMOUS
    krbtgt/DEVOPS.GSI.DE
    kadmin> add --random-key host/lxb002.devops.gsi.de
    Max ticket life [1 day]:
    Max renewable life [1 week]:
    Principal expiration time [never]:
    Password expiration time [never]:
    Attributes []:
    kadmin> list *
    default
    almudena
    kadmin/admin
    kadmin/hprop
    kadmin/changepw
    changepw/kerberos
    WELLKNOWN/ANONYMOUS
    krbtgt/DEVOPS.GSI.DE
    host/lxb002.devops.gsi.de
    kadmin> ext_keytab --keytab=/tmp/keytab host/lxb002.devops.gsi.de
    kadmin> exit

    devops@lxb002:~$sudo mv /tmp/keytab /etc/krb5.keytab


Our sample client will be a ssh server.  
We modify the configuration of our ssh server to accept API authentication:

    --bash
    root@lxb002:/etc# echo "GSSAPIAuthentication yes" >> /etc/ssh/sshd_config
    root@lxb002:/etc# echo "KerberosAuthentication yes" >>/etc/ssh/sshd_config
    root@lxb002:/etc# /etc/init.d/ssh restart
    root@lxb002:/etc# useradd -m -s /bin/bash almudena # we dont set a password, we will use kerberos

Now we install a third machine, with heimdal::client too. This will be the ssh client testing the ssh-server kerberized with the account almudena.

 * We create again here an account with no password:

    --bash
    root@lxb003:/home/devops# useradd -m -s /bin/bash almudena
    devops@lxb003:~$ su - almudena
    Password: 
    almudena@lxb003:~$ klist
    Credentials cache: FILE:/tmp/krb5cc_1001_EI5sxs
        Principal: almudena@DEVOPS.GSI.DE

  Issued           Expires          Principal
May 11 12:35:16  May 11 22:35:16  krbtgt/DEVOPS.GSI.DE@DEVOPS.GSI.DE



This is what we see in the kdc log file: 
2012-05-11T12:35:16 ENC-TS Pre-authentication succeeded -- almudena@DEVOPS.GSI.DE using aes256-cts-hmac-sha1-96
2012-05-11T12:35:16 AS-REQ authtime: 2012-05-11T12:35:16 starttime: unset endtime: 2012-05-11T22:35:16 renew till: unset
2012-05-11T12:35:16 Client supported enctypes: aes256-cts-hmac-sha1-96, aes128-cts-hmac-sha1-96, des3-cbc-sha1, des3-cbc-md5, arcfour-hmac-md5, using aes256-cts-hmac-sha1-96/aes256-cts-hmac-sha1-96
2012-05-11T12:35:16 Requested flags: proxiable, forwardable
2012-05-11T12:35:16 sending 667 bytes to IPv4:10.1.1.6

We attempt now to connect to the ssh server, this is the kdc output

2012-05-11T12:38:29 AS-REQ almudena@DEVOPS.GSI.DE from IPv4:10.1.1.5 for krbtgt/DEVOPS.GSI.DE@DEVOPS.GSI.DE
2012-05-11T12:38:29 No preauth found, returning PREAUTH-REQUIRED -- almudena@DEVOPS.GSI.DE
2012-05-11T12:38:29 sending 279 bytes to IPv4:10.1.1.5
2012-05-11T12:38:29 AS-REQ almudena@DEVOPS.GSI.DE from IPv4:10.1.1.5 for krbtgt/DEVOPS.GSI.DE@DEVOPS.GSI.DE
2012-05-11T12:38:29 Client sent patypes: encrypted-timestamp
2012-05-11T12:38:29 Looking for PKINIT pa-data -- almudena@DEVOPS.GSI.DE
2012-05-11T12:38:29 Looking for ENC-TS pa-data -- almudena@DEVOPS.GSI.DE
2012-05-11T12:38:29 ENC-TS Pre-authentication succeeded -- almudena@DEVOPS.GSI.DE using aes256-cts-hmac-sha1-96
2012-05-11T12:38:29 AS-REQ authtime: 2012-05-11T12:38:29 starttime: unset endtime: 2012-05-11T22:38:29 renew till: unset
2012-05-11T12:38:29 Client supported enctypes: aes256-cts-hmac-sha1-96, aes128-cts-hmac-sha1-96, des3-cbc-sha1, des3-cbc-md5, arcfour-hmac-md5, using aes256-cts-hmac-sha1-96/aes256-cts-hmac-sha1-96
2012-05-11T12:38:29 Requested flags: proxiable, forwardable
2012-05-11T12:38:29 sending 667 bytes to IPv4:10.1.1.5
2012-05-11T12:38:29 TGS-REQ almudena@DEVOPS.GSI.DE from IPv4:10.1.1.5 for host/lxb002.devops.gsi.de@DEVOPS.GSI.DE [canonicalize]
2012-05-11T12:38:29 TGS-REQ authtime: 2012-05-11T12:38:29 starttime: 2012-05-11T12:38:29 endtime: 2012-05-11T22:38:29 renew till: unset
2012-05-11T12:38:29 sending 676 bytes to IPv4:10.1.1.5

When we disconnect and try to connect again, we should not be asked for the password again, sso.


tail /var/log/auth.log

